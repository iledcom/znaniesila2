<?php
// Это страница входа для сайта
// Она включена с помощью сценария index.php, который получает данные формы регистрации
// Этот сценарий создан в главе 4

// Массив, предназначенный для регистрации ошибок
$login_errors = array();

// Проверка адреса электронной почты
if (filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) {
	$e = escape_data($_POST['email'], $dbc);
 } else {
	$login_errors['email'] = 'Введите корректный адрес электронной почты!';
 }

 // Проверка пароля
 if (!empty($_POST['pass'])) {
	$p = $_POST['pass'];
 }  else {
	$login_errors['pass'] = 'Пожалуйста, введите пароль!';
 }

 if (empty($login_errors)) { // OK для обработки!

	// Запрос базы данных
	$q = "SELECT id, username, type, pass, IF(date_expires >= NOW(), true, false) AS expired FROM users WHERE email='$e'";		
	$r = mysqli_query($dbc, $q);

	if (mysqli_num_rows($r) === 1) { // Если в результате выполнения запроса к базе данных возвращается единственная строка, то осуществляется выборка данных

		// Получение данных
		$row = mysqli_fetch_array($r, MYSQLI_ASSOC);
		// При использовании константы MYSQLI_ASSOC функция будет вести себя идентично mysqli_fetch_assoc()
		// mysqli_result::fetch_assoc -- mysqli_fetch_assoc — Извлекает результирующий ряд в виде ассоциативного массива 

		//Значение этого условного выражения будет равно true, если в базе данных хранится такой же адрес электронной почты.

		// Проверка пароля
		// Включение библиотеки password_compat в случае необходимости
		// include('./includes/lib/password.php');

		if (password_verify($p, $row['pass'])) { // корректно
			// Если пользователь является администратором, безопаснее создать новый идентификатор сеанса
			// Этот код создан в конце главы 4
			if ($row['type'] === 'admin') {
				session_regenerate_id(true);
				//session_regenerate_id() заменяет идентификатор текущей сессии вновь сгенерированным, при этом сохраняет информацию о текущей сессии.
				$_SESSION['user_admin'] = true;
			}

			//Если пользователь является администратором, то выполните следующие действия. Во-первых, для обеспечения безопасности следует изменить идентификатор сеанса. В результате предотвращаются атаки с фиксацией сеанса. В ходе осуществления этой атаки хакер устанавливает идентификатор сеанса пользователя таким образом, чтобы он соответствовал собственному идентификатору сеанса хакера. В результате хакер получает возможность доступа к вашей системе с правами администратора. Для организации подобных атак используется функция session_regenerate_id(). Затем останется создать лишь элемент $_session['user admin'], принимающий значение true в том случае, если значение типа пользователя будет admin. В данном случае нежелательно создание элемента $_SESSION['user admin'], принимающего значение false, если тип пользователя будет member. Это связано с тем, что функция, которая проверяет наличие доступа пользователя к страницам (redirect_invalid_user (), заданная в файле config.inc.php), будет проверять, установлена ли переменная сеанса, не проверяя ее фактическое значение.

			// Сохранение данных в сеансе
			$_SESSION['user_id'] = $row['id'];
			$_SESSION['username'] = $row['username'];

			// Показывает, что срок действия учетной записи пользователя не истек
			if ($row['expired'] === 1) $_SESSION['user_not_expired'] = true;

			} else { // корректный адрес электронной почты, неверный пароль
			$login_errors['login'] = 'Адрес электронной почты и пароль не соответствуют адресу и паролю, которые хранятся в файле.';
			}
			
	} else { // Сравнение не выполнено (технически неверен только адрес электронной почты)
		$login_errors['login'] = 'Адрес электронной почты и пароль не соответствуют адресу и паролю, которые хранятся в файле.';
	}
	
} // Конец $login_errors IF.

// Пропустить закрывающий тег PHP, чтобы избежать ошибок 'headers are sent'!